{"name":"Lympid-core","tagline":"","body":"# Overview\r\n\r\nThis project is a Java implementation of the **UML state machine** specification as\r\ndescribed in [UML superstructure 2.4.1](http://fabienrenaud.github.io/lympid/lympid-core/docs/UML superstructure 2.4.1.pdf).\r\nIt is implemented with **Java 8** and packaged as a valid **OSGi bundle**.\r\n\r\nThe implementation supports nearly every single feature of behavioral state machines:\r\n\r\n  * states: simple, composite, orthogonal and submachine\r\n  * pseudo states: initial, entry point, exit point, junction, choice, join, fork, shallow history, deep history and terminate\r\n  * transitions: external, internal and local\r\n  * transition events, transition guards, transition effects, the two latter have easy and typed access to the event and context data\r\n  * state entry and state exit behaviors, with easy and typed access to context data\r\n  * asynchronous state activity behaviors, with easy and typed access to context data\r\n  * completion events (transition with no triggers/events)\r\n  * time events\r\n  * custom events\r\n\r\nand comes with an easy-to-use builder API that takes away from the developer the inherent complexity of UML state machines.\r\n\r\nOther features include, but not only:\r\n\r\n  * build once, use many times: `StateMachine` instances do not contain any execution data and are not changed throughout the execution of a state machine. Therefore, they can be reused as many times as necessary.\r\n  * various state machine executors: synchronous/synchronized executor, lock executor, queued executor, sharded executor\r\n  * state machine listeners: to listen to everything that happens in the state machine\r\n  * prioritized transitions: when more than one transition is enabled for a (pseudo) state, only one will be fired. You can define which it will be.\r\n  * configurable state machine executor: auto start, thread pool for asynchronous events and activities, ...\r\n\r\nIt is heavily **tested with more than 120 state machines and more than 700 unit tests**. Code and branch coverage is above 90%.\r\n\r\nThis project is licensed under the [Apache License 2.0](http://www.apache.org/licenses/LICENSE-2.0)\r\n\r\n[![Build Status](https://travis-ci.org/lympid/lympid-core.svg?branch=master)](https://travis-ci.org/lympid/lympid-core) [![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.lympid/lympid-core/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.lympid/lympid-core)\r\n\r\n\r\n# Get it!\r\n\r\n## Maven\r\n\r\nFunctionality of this project is contained in the Java package `com.lympid.core`.\r\n\r\nAdd the following dependency to your `pom` to use this package:\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>com.lympid</groupId>\r\n  <artifactId>lympid-core</artifactId>\r\n  <version>0.9.0</version>\r\n</dependency>\r\n```\r\n\r\n## Non-Maven\r\n\r\nJars are also available for direct download on [maven central repository](http://repo1.maven.org/maven2/com/lympid/lympid-core/).\r\n\r\n# Use it!\r\n\r\nUML state machine is not an easy topic for the non-initiated.\r\n\r\n## Tutorial 1: A simple state machine\r\n\r\nLet's implement the following state machine which describe an on/off switch:\r\n\r\n![tutorial1](http://fabienrenaud.github.io/lympid/lympid-core/docs/Tutorial1/diagram.png)\r\n\r\nFirst, create your state machine builder:\r\n\r\n```java\r\nStateMachineBuilder builder = new StateMachineBuilder(\"OnOff\");\r\n```\r\n\r\nAnd build the initial vertex with all its outgoing transitions:\r\n\r\n```java\r\nbuilder                  // the state machine builder\r\n  .region()              // a (pseudo) state always belong to a region!\r\n    .initial()           // adds an initial pseudo state in this region\r\n      .transition(\"t0\")  // adds a transition named \"t0\" to the initial pseudo state\r\n        .target(\"off\");  // defines the target of the initial transition\r\n```\r\n\r\nNow, repeat the operation for the next (pseudo) state. Let's do the \"off\" state:\r\n\r\n```java\r\nbuilder\r\n  .region()              // this is the same region as before, same instance.\r\n    .state(\"off\")        // creates a simple state named \"off\"\r\n      .transition(\"t1\")  // adds an external transition named \"t1\" to the state \"off\"\r\n        .on(\"ON\")        // t1 can only be fired when the state machine receives the event \"ON\"\r\n        .target(\"on\")    // t1 targets the \"on\" vertex\r\n      .transition(\"t3\")  // adds an external transition named \"t3\" to the state \"off\"\r\n        .on(\"KILL\")      // t3 can only be fired when the state machine receives the event \"KILL\"\r\n        .target(\"end\");  // t3 targets the \"end\" vertex\r\n```\r\n\r\nAnd again with the vertex \"on\":\r\n\r\n```java\r\nbuilder\r\n  .region()\r\n    .state(\"on\")\r\n      .transition(\"t2\")\r\n        .on(\"OFF\")\r\n        .target(\"off\");\r\n```\r\n\r\nAnd the final state:\r\n\r\n```java\r\nbuilder\r\n  .region()\r\n    .finalState(\"end\");\r\n```\r\n\r\nNow, get a `StateMachine` instance, choose which `StateMachineExecutor` you want to use and start it:\r\n\r\n```java\r\nStateMachine machine = builder.newInstance(); // builds and validates the state machine; the result is cached\r\n\r\nStateMachineExecutor fsm = new SyncStateMachineExecutor();\r\nfsm.setStateMachine(machine);\r\nfsm.go();\r\n```\r\n\r\nWhen `go` is invoked, the state machine auto starts by default and the initial transition is fired.\r\nTherefore, the state machine is now on state \"off\", waiting for either event \"ON\" or event \"KILL\".\r\nYou can see so by takign a snapshot of the state machine and looking at its active state configuration:\r\n\r\n```java\r\nSystem.out.println(fsm.snapshot().activateStates()); // outputs off\r\n```\r\n\r\nThen, use the `take` method to feed the state machine with events. For instance:\r\n\r\n```java\r\nfsm.take(new StringEvent(\"ON\"));\r\nSystem.out.println(fsm.snapshot().activateStates()); // outputs on\r\n\r\nfsm.take(new StringEvent(\"OFF\"));\r\nSystem.out.println(fsm.snapshot().activateStates()); // outputs off\r\n\r\nfsm.take(new StringEvent(\"KILL\"));\r\nSystem.out.println(fsm.snapshot().activateStates()); // outputs end\r\n```\r\nAnd that's it!\r\n\r\n## More tutorials to come...\r\n\r\nMeanwhile, you can the hundred of test state machines this project has\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}